     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13 00000000 010000000200000003-         a DD 1, 2, 3, 0xABCDEF00
    13 00000009 00000000EFCDAB     
    14                                      ; 01 00 00 00
    15                                      ; 02 00 00 00
    16                                      ; 03 00 00 00
    17                                      ; 00 EF CD AB
    18                                      ;        ^
    19                                      len_a EQU ($ - a) / 4
    20 00000010 00<rept>                    b TIMES len_a DB 0
    21                                      
    22                                  ; our code starts here
    23                                  segment code use32 class=code
    24                                      start:
    25                                          ; A string of doublewords is given. Compute the string formed by the high bytes of the low words from the elements of the doubleword string and these bytes should be multiple of 10
    26                                      
    27                                          ; Initialize our values
    28 00000000 B904000000                      mov ecx, len_a
    29 00000005 FC                              cld ; DF = 0, REALLY IMPORTANT
    30 00000006 BE[00000000]                    mov esi, a ; ADDRESSES!
    31 0000000B BF[10000000]                    mov edi, b
    32                                          
    33 00000010 E315                            jecxz the_end
    34                                          
    35                                          my_loop:
    36 00000012 AD                                  lodsd ; eax = a[i]
    37 00000013 88E0                                mov al, ah ; get the high byte of the low word into place (same as shr ax, 8)
    38 00000015 88C2                                mov dl, al ; save al into dl
    39 00000017 6698                                cbw ; al -> ax
    40                                              
    41 00000019 B30A                                mov bl, 10
    42 0000001B F6FB                                idiv bl ; al = quotient, ah = remainder
    43                                              ; if ah == 0, then the nr is a multiple of 10
    44 0000001D 80FC00                              cmp ah, 0
    45 00000020 7503                                jne next
    46                                              ; else (if divisible by 0)
    47 00000022 88D0                                mov al, dl ; restore saved byte from before
    48 00000024 AA                                  stosb ; b[j] = al (a[i])
    49                                              
    50                                              next:
    51 00000025 E2EB                                loop my_loop
    52                                          
    53                                          the_end:
    54                                      
    55                                          ; exit(0)
    56 00000027 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    57 00000029 FF15[00000000]                  call    [exit]       ; call exit to terminate the program
